<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>POTRABASH - Original Art Edition</title>
<style>
/* èƒŒæ™¯ãƒ»ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
body{background:#0b6623 url('hosi.png') no-repeat center center; background-size: cover; color:white; font-family:sans-serif; margin:0; padding:0; overflow:hidden; height: 100vh;}
.game-container { display: flex; justify-content: space-between; width: 100vw; height: 100vh; position: relative; }
.main-play-area { flex-grow: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1; overflow: auto; }

/* ã‚µã‚¤ãƒ‰ãƒ‘ãƒãƒ«ï¼ˆã‚µãƒãƒªãƒ¼ï¼‰ */
.side-panel { width: 280px; padding: 10px; box-sizing: border-box; z-index: 100; pointer-events: none; }
.side-panel > * { pointer-events: auto; }
.status-box { background: rgba(0, 0, 0, 0.7); border: 2px solid #ffd700; border-radius: 12px; padding: 15px; text-align: center; box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
#current-part { color: #ffd700; margin: 0 0 5px 0; font-size: 1.2rem; }
.summary-box { background: rgba(0, 0, 0, 0.85); border-left: 2px solid rgba(255, 215, 0, 0.3); padding: 12px; height: 95vh; font-size: 0.75rem; overflow-y: auto; line-height: 1.4; }
.summary-box h3 { color: #ffd700; border-bottom: 1px solid; padding-bottom: 5px; margin-top: 0; font-size: 1rem; }
.summary-section { margin-bottom: 12px; padding: 8px; transition: 0.3s; border-radius: 6px; }
.summary-section h4 { color: #ffd700; margin: 0 0 5px 0; font-size: 0.85rem; border-bottom: 1px solid rgba(255,215,0,0.2); }
.active-section { background: rgba(255, 215, 0, 0.15); border: 1px solid #ffd700; }
.lang-en { color: #ccc; font-style: italic; display: block; margin-top: 3px; border-top: 1px dashed rgba(255,255,255,0.1); padding-top: 2px; }

/* ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ */
#titleScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; background: rgba(0,0,0,0.4); }
.title-logo { width: 600px; max-width: 90%; height: auto; margin-bottom: 20px; filter: drop-shadow(0 0 15px rgba(0,0,0,0.5)); }
#titleScreen .menu { background: rgba(0,0,0,0.7); padding: 30px; border-radius: 20px; border: 2px solid rgba(255,255,255,0.2); text-align: center; backdrop-filter: blur(5px); }
#ui{width:100%;text-align:center;padding:10px 0;background:rgba(0,0,0,0.6);position:relative;z-index:200; display: none;}
#table{position:relative;width:1000px;height:700px;margin:auto; display: none;}
#center{position:absolute;top:50%;left:42%;transform:translate(-50%,-50%);width:160px;height:220px;background:rgba(6,68,32,0.8);border-radius:12px;text-align:center;padding:10px;z-index:5;box-shadow: 0 0 20px rgba(0,0,0,0.8);border: 2px solid #0a5a2a;}

.player{position:absolute;width:280px;padding:10px;border-radius:15px;z-index:20;transition: all 0.3s; background:rgba(0,0,0,0.4); backdrop-filter: blur(4px); border: 1px solid rgba(255,255,255,0.1);}
.player.human, .player.reveal-all { width: 360px; min-height: 200px; background:rgba(255,255,255,0.15); z-index: 50;}
.hand, .field { display: flex; justify-content: center; gap: 6px; margin: 6px 0; min-height: 80px; position: relative; }
.card { width: 50px; height: 75px; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 20px; box-shadow: 2px 2px 5px rgba(0,0,0,0.5); background-size: 100% 100%; position: relative; color: white; text-shadow: 1px 1px 2px black; transition: transform 0.2s; }

.human .hand .card { width: 80px; height: 120px; font-size: 36px; cursor: pointer; margin: 0 2px; }
.human .hand .card:hover { transform: translateY(-10px) scale(1.05) !important; z-index: 100; }
.player:not(.human) .hand .card { position: absolute; margin-left: -20px; }

.score-container { display: flex; gap: 3px; justify-content: flex-start; flex-wrap: wrap; margin-top: 10px; min-height: 60px; position: relative; }
.score-card-messy { position: absolute; }

.v-3{background-color:#8b0000;}.v-2{background-color:#c0392b;}.v1{background-color:#ecf0f1; color:black; text-shadow: none;}.v3{background-color:#5dade2;}.v4{background-color:#f4d03f; color:black; text-shadow: none;}.back{background-color:#1c2833; border:1px solid #34495e;}
.dead{filter: grayscale(100%) brightness(40%); border: 3px solid red !important;}.dead::after{content:"Ã—";font-size:50px;position:absolute;color:#ff0000;font-weight:900;top:50%;left:50%;transform:translate(-50%,-50%);text-shadow:none;z-index:100;}
.selectable{outline:4px solid #fff;cursor:pointer;animation:pulse 0.8s infinite}
@keyframes pulse { 0%{transform:scale(1)} 50%{transform:scale(1.05)} 100%{transform:scale(1)} }

button { padding: 10px 20px; cursor: pointer; border-radius: 8px; border: none; background: #eee; font-weight: bold; color: #333; transition: 0.2s; touch-action: manipulation;}
.btn-large { font-size: 24px; padding: 15px 40px; background: #f1c40f; color: #000; box-shadow: 0 4px 10px rgba(0,0,0,0.3); }
.flying-card { position: fixed; z-index: 9999; pointer-events: none; }
</style>
</head>
<body>

<audio id="bgm" loop><source src="https://www.dropbox.com/scl/fi/49sn3at2wqynqjrvbazhr/bgm.mp3?rlkey=vq7qobgw31mljqu9xbs6pdkul&st=x7cbq7kf&raw=1" type="audio/mpeg"></audio>

<div id="titleScreen">
    <img src="rogo.png" alt="POTRABASH" class="title-logo">
    <div class="menu">
        <p style="font-size: 18px; margin-bottom: 20px;">Nightmare Mode (Original Art)</p>
        <div style="margin-bottom: 25px;">
            <button onclick="window.open('rule.pdf', '_blank')" style="background:#444; color:white; border:1px solid #777; padding:8px 15px; margin-bottom:10px; width:200px;">ğŸ“– ãƒ«ãƒ¼ãƒ«ã‚’èª­ã‚€ (æ—¥æœ¬èª)</button><br>
            <button onclick="window.open('rule_en.pdf', '_blank')" style="background:#224; color:white; border:1px solid #55a; padding:8px 15px; width:200px;">ğŸŒ English Rules (PDF)</button>
        </div>
        <select id="playerCount" style="font-size: 20px; padding: 5px; margin-bottom: 30px;">
            <option value="3">3äºº</option>
            <option value="4" selected>4äºº</option>
            <option value="5">5äºº</option>
        </select><br>
        <button class="btn-large" onclick="initGame()">Game Start</button>
    </div>
</div>

<div class="game-container">
    <aside class="side-panel left-panel" id="sideStatus" style="display: none;">
        <div class="status-box">
            <h2 id="current-part">è´ˆä¸ãƒ‘ãƒ¼ãƒˆ</h2>
            <p id="current-phase">æº–å‚™ä¸­</p>
            <p id="instruction-text" style="font-size: 0.8rem; color: #ccc;">å±±æœ­ã‹ã‚‰ã‚«ãƒ¼ãƒ‰ãŒã‚ãã‚‰ã‚Œã¾ã™ã€‚</p>
        </div>
    </aside>

    <main class="main-play-area">
        <div id="ui"><span id="infoLabel" style="font-weight: bold; margin-right: 20px;"></span><button onclick="backToTitle()">ã‚¿ã‚¤ãƒˆãƒ«ã¸æˆ»ã‚‹</button></div>
        <div id="table">
            <div id="center">
                <div style="font-size:14px;margin-bottom:8px">ä¸­å¤®ç²å¾—ã‚«ãƒ¼ãƒ‰</div>
                <div id="centerCard" class="card" style="margin:0 auto 15px auto; width:80px; height:120px;"></div>
                <button id="passBtn" onclick="pass()">ãƒ‘ã‚¹ã—ã¦çµ‚äº†</button>
            </div>
        </div>
    </main>

    <aside class="side-panel right-panel" id="right-panel" style="display: none;">
        <div class="summary-box">
            <h3>Summary / ã‚µãƒãƒªãƒ¼</h3>
            <section class="summary-section active-section" id="sum-gift">
                <h4>1. Gift Part / è´ˆä¸ãƒ‘ãƒ¼ãƒˆ</h4>
                <ul>
                    <li>P1: å¿…é ˆ / P2ãƒ»3: ä»»æ„<br><span class="lang-en">P1: Must / P2,3: Optional</span></li>
                    <li>åˆè¨ˆå€¤ãŒæœ€å¤§ã®äººãŒä¸­å¤®ç²å¾—<br><span class="lang-en">Highest sum wins the center card.</span></li>
                    <li>åŒç‚¹ã¯æœ€å¾Œã«ã‚«ãƒ¼ãƒ‰ã‚’å‡ºã—ãŸäºº<br><span class="lang-en">Ties broken by the last player to play.</span></li>
                </ul>
            </section>
            <section class="summary-section" id="sum-acquisition">
                <h4>2. Acquisition / ç²å¾—ãƒ‘ãƒ¼ãƒˆ</h4>
                <ol><li>ä¸­å¤®å‹è€…ã‹ã‚‰æ™‚è¨ˆå›ã‚Šã«ã€ä»–è€…ã®å ´ã‹ã‚‰1æšãšã¤å¥ªã†<span class="lang-en">Starting from the winner, pick 1 card from another's field clockwise.</span></li></ol>
            </section>
            <section class="summary-section">
                <h4>3. Scoring / ã‚¹ã‚³ã‚¢è¨ˆç®—</h4>
                <ul>
                    <li>åŒã˜æ•°å­—3æšã§æ¶ˆæ»…<br><span class="lang-en">Sets of 3 identical numbers are discarded.</span></li>
                    <li>åŒç‚¹ã¯ã€Œ1ã€ãŒå¤šã„æ–¹ã®å‹ã¡<br><span class="lang-en">Ties: Person with more "1" cards wins.</span></li>
                    <li>ãã‚Œã‚‚åŒã˜ãªã‚‰åŒæ™‚å‹åˆ©<br><span class="lang-en">Still tied? Shared victory.</span></li>
                </ul>
            </section>
        </div>
    </aside>
</div>

<script>
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSwooshSound() {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const duration = 0.15;
    const bufferSize = audioCtx.sampleRate * duration;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; }
    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;
    const filter = audioCtx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.setValueAtTime(3000, audioCtx.currentTime);
    filter.frequency.exponentialRampToValueAtTime(1500, audioCtx.currentTime + duration);
    filter.Q.value = 1.0;
    const gainNode = audioCtx.createGain();
    gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
    gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + duration);
    noise.connect(filter); filter.connect(gainNode); gainNode.connect(audioCtx.destination);
    noise.start(); noise.stop(audioCtx.currentTime + duration);
}

const personalities = [ { name: "å¼·æ¬²" }, { name: "æ…é‡" }, { name: "åˆºå®¢" }, { name: "å¤§å™¨" } ];
let players=[], deck=[], playerCount=4, startIndex=0, turnIndex=0, lap=1, centerCard=null, phase="title", pickIndex=0;
let lastPlayOrder = []; 

function updateUIPanels(part, phaseName, instruct) {
    document.getElementById('current-part').innerText = part;
    document.getElementById('current-phase').innerText = phaseName;
    document.getElementById('instruction-text').innerText = instruct;
    const g = document.getElementById('sum-gift');
    const a = document.getElementById('sum-acquisition');
    if(part==="è´ˆä¸ãƒ‘ãƒ¼ãƒˆ"){ g.classList.add('active-section'); a.classList.remove('active-section'); }
    else if(part==="ç²å¾—ãƒ‘ãƒ¼ãƒˆ"){ g.classList.remove('active-section'); a.classList.add('active-section'); }
}

function initGame() {
    playerCount = parseInt(document.getElementById("playerCount").value);
    document.getElementById("titleScreen").style.display = "none";
    document.getElementById("ui").style.display = "block";
    document.getElementById("table").style.display = "block";
    document.getElementById("sideStatus").style.display = "block";
    document.getElementById("right-panel").style.display = "block";
    const bgm = document.getElementById("bgm"); bgm.volume = 0.3; bgm.play().catch(e => {});
    if (audioCtx.state === 'suspended') audioCtx.resume();
    startGame();
}

function backToTitle() { location.reload(); }

// --- AIå¼·åŒ–æ€è€ƒãƒ­ã‚¸ãƒƒã‚¯ (è´ˆä¸) ---
function aiThink(p) {
    const trait = p.trait.name;
    const mySum = p.field.reduce((a,v)=>a+v.value, 0);
    const others = players.filter(o => o.id !== p.id);
    const maxOther = Math.max(...others.map(o => o.field.reduce((a,v)=>a+v.value, 0)));
    
    const nextPlayerIdx = (players.indexOf(p) + 1) % playerCount;
    const nextPlayer = players[nextPlayerIdx];
    const nextPlayerSum = nextPlayer.field.reduce((a,v)=>a+v.value, 0);

    const centerIsOne = (centerCard && centerCard.value === 1);
    const myMinusCount = centerCard && centerCard.value < 0 ? p.score.filter(s => s.value === centerCard.value).length : 0;
    const hasSameMinus = (myMinusCount > 0);
    const isSpecialTrait = (trait === "æ…é‡" || trait === "å¤§å™¨" || trait === "åˆºå®¢");

    if (!( (centerIsOne || hasSameMinus) && isSpecialTrait )) {
        if (lap > 1 && mySum > maxOther && mySum > 0) return {action: "pass"};
        if (lap > 2 && mySum === maxOther && mySum > 0) return {action: "pass"};
        if (isSpecialTrait && lap > 1 && mySum >= nextPlayerSum) return {action: "pass"};
    }
    
    const choices = p.hand.map((c, idx) => {
        let score = 0; 
        const proj = mySum + c.value;

        if (trait === "å¼·æ¬²") { 
            if(c.value >= 3) score -= 100; 
            if(proj > maxOther) score += 200; 
        } 
        else if (isSpecialTrait) {
            if (centerIsOne && proj > maxOther) { score += 100000; }
            else if (hasSameMinus && proj > maxOther) {
                // å¸³æ¶ˆã—ãƒªãƒ¼ãƒ(2æšæ‰€æŒ)ãªã‚‰è¶…çµ¶å„ªå…ˆã€1æšãªã‚‰å„ªå…ˆ
                score += (myMinusCount === 2) ? 80000 : 40000;
            }
            else {
                if (proj < nextPlayerSum) score += 1000;
                if (c.value < 0) score += 500;
                if (proj > nextPlayerSum) score -= 2000;
            }
            if (trait === "æ…é‡") { if(p.score.some(s=>s.value===c.value)) score += 300; }
            if (trait === "å¤§å™¨") { if(c.value === 1) score -= 400; }
        }

        if ((centerIsOne || hasSameMinus) && others.some(o => o.field.reduce((a,v)=>a+v.value,0) === proj && proj > 0)) {
            score += 2000; 
        }
        return {idx, score: score + Math.random() * 50};
    }).sort((a,b)=>b.score - a.score);

    return {action: "play", index: choices[0].idx};
}

// --- AIå¼·åŒ–æ€è€ƒãƒ­ã‚¸ãƒƒã‚¯ (ç²å¾—ãƒ»å¥ªã„åˆã„) ---
function nextPick() {
    if (!players.some(p => p.field.length)) { 
        startIndex = (pickIndex) % playerCount; 
        if (deck.length === 0 && players[0].hand.length === 0) return endGame(); 
        return nextRound(); 
    }
    const p = players[pickIndex];
    let others = players.filter(o => o.id !== p.id && o.field.length);
    let targets = others.length > 0 ? others : [p];
    updateUIPanels("ç²å¾—ãƒ‘ãƒ¼ãƒˆ", `å›åä¸­ (P${p.id})`, (p.id === 0) ? "å ´ã‹ã‚‰1æšå–ã£ã¦ãã ã•ã„ã€‚" : `P${p.id}ãŒç²å¾—ä¸­...`);
    if (p.id === 0) { render(true, targets.map(t => t.id)); return; }
    
    const trait = p.trait.name; let bestT = targets[0], bestCi = 0, bestScore = -999999;
    targets.forEach(t => {
        t.field.forEach((c, ci) => {
            let s = 0; const isHuman = (t.id === 0);
            const myOwnedCount = p.score.filter(sc => sc.value === c.value).length;
            
            // â˜…æœ€å„ªå…ˆï¼š3æšæƒã£ã¦æ¶ˆãˆã‚‹ã‚«ãƒ¼ãƒ‰ (å¸³æ¶ˆã—ç‹™ã„)
            if (myOwnedCount === 2) {
                s += (c.value < 0) ? 200000 : 50000; // ãƒã‚¤ãƒŠã‚¹æœ­ã®å¸³æ¶ˆã—ã‚’æœ€é«˜è©•ä¾¡
            } 
            // æ¬¡ç‚¹ï¼š2æšç›®ã«ãªã‚‹ã‚«ãƒ¼ãƒ‰ (ãƒªãƒ¼ãƒä½œã‚Š)
            else if (myOwnedCount === 1) {
                s += (c.value < 0) ? 15000 : 10000;
            }

            if (trait === "åˆºå®¢") {
                if (isHuman) { const hCount = t.score.filter(sc => sc.value === c.value).length; if (hCount === 2) { if (c.value < 0) s += 20000; if (c.value >= 1) s -= 10000; } }
                if (c.value === 1 && myOwnedCount < 2) s += 12000; // 1ã¯å¸¸ã«å¼·ã„
            } else if (trait === "å¤§å™¨") {
                if (c.value === 1 && myOwnedCount < 2) s += 30000;
            } else if (trait === "å¼·æ¬²") {
                if (c.value >= 3 && myOwnedCount < 2) s += 8000;
            } else if (trait === "æ…é‡") {
                if (c.value < 0 && myOwnedCount === 0) s -= 10000; // æŒã£ã¦ãªã„ãƒã‚¤ãƒŠã‚¹ã¯é¿ã‘ã‚‹
            }

            // å ´ã«æ®‹ã£ã¦ã„ã‚‹åˆè¨ˆå€¤ãŒé«˜ã„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰å¥ªã†
            const tSum = t.field.reduce((a,v)=>a+v.value,0); if (tSum > 0) s += tSum * 150;
            
            if (s > bestScore) { bestScore = s; bestT = t; bestCi = ci; }
        });
    });
    executePick(p.id, bestT.id, bestCi);
}

function executePick(pickerId, targetId, cardIdx) {
    const picker = players[pickerId]; const target = players[targetId];
    if(!target || !target.field[cardIdx]) { nextPick(); return; }
    const fromEl = document.querySelector(`.player-id-${targetId} .field .card:nth-child(${cardIdx + 1})`);
    const c = target.field.splice(cardIdx, 1)[0];
    animateCardSlide(fromEl, `.player-id-${pickerId} .score-anchor`, c.value, (pickerId !== 0), () => {
        picker.score.push(c); pickIndex = (pickIndex + 1) % playerCount; render(); setTimeout(nextPick, 300);
    });
}

function humanPick(targetIdx, cardIdx) { if (phase !== "pick" || pickIndex !== 0) return; executePick(0, targetIdx, cardIdx); }

function startPick(){
    phase="pick"; const centerEl = document.getElementById("centerCard");
    const sums = players.map(p => p.field.reduce((a,c)=>a+c.value,0));
    const maxSum = Math.max(...sums);
    let winners = []; sums.forEach((s, idx) => { if(s === maxSum) winners.push(idx); });
    let winner = winners[0];
    if (winners.length > 1) {
        for(let i = lastPlayOrder.length - 1; i >= 0; i--) { if(winners.includes(lastPlayOrder[i])) { winner = lastPlayOrder[i]; break; } }
    }
    updateUIPanels("ç²å¾—ãƒ‘ãƒ¼ãƒˆ", "ä¸­å¤®ç²å¾—", `P${winner}ãŒä¸­å¤®ã‚’ç²å¾—ï¼`);
    animateCardSlide(centerEl, `.player-id-${winner} .score-anchor`, centerCard.value, (winner!==0), () => {
        players[winner].score.push(centerCard); centerEl.style.visibility = "hidden";
        pickIndex = (winner + 1) % playerCount; render(); setTimeout(nextPick, 300);
    });
}

function endGame(){
    phase = "end";
    updateUIPanels("çµ‚äº†", "æœ€çµ‚çµæœ", "ãŠç–²ã‚Œæ§˜ã§ã—ãŸï¼");
    players.forEach(p => {
        let groups = {};
        p.score.forEach(c => { 
            if (!groups[c.value]) groups[c.value] = []; 
            groups[c.value].push(c); 
        });
        p.total = 0; p.score.forEach(c => c.isDead = false);
        Object.keys(groups).forEach(val => {
            let cards = groups[val]; let numDead = Math.floor(cards.length / 3) * 3;
            for (let i = 0; i < numDead; i++) cards[i].isDead = true;
        });
        p.score.forEach(c => { if (!c.isDead) p.total += c.value; });
    });
    let maxTotal = Math.max(...players.map(p => p.total));
    let candidates = players.filter(p => p.total === maxTotal);
    let maxOnes = -1;
    candidates.forEach(p => {
        p.oneCount = p.score.filter(c => c.value === 1 && !c.isDead).length;
        if (p.oneCount > maxOnes) maxOnes = p.oneCount;
    });
    players.forEach(p => {
        p.isAbsoluteWinner = (p.total === maxTotal && (p.oneCount || 0) === maxOnes);
    });
    render();
}

function updateInfo() { document.getElementById("infoLabel").innerText = `å±±æœ­æ®‹ã‚Š: ${deck.length}æš`; }
function makeDeck(){let d=[];[-3,-2,1,3,4].forEach(v=>{for(let i=0;i<12;i++)d.push({value:v});});return d.sort(()=>Math.random()-0.5);}

function startGame(){
    deck=makeDeck(); if(playerCount===3) {
        let newDeck = [];
        [-3,-2,1,3,4].forEach(v => { let count=0; deck.forEach(c => { if(c.value === v && count < 10) { newDeck.push(c); count++; } }); });
        deck = newDeck.sort(()=>Math.random()-0.5);
    }
    players=[]; let shuffledTraits = [...personalities].sort(() => Math.random() - 0.5);
    for(let i=0;i<playerCount;i++) {
        let trait = (i === 0) ? null : shuffledTraits[(i - 1) % shuffledTraits.length];
        players.push({ id:i, hand:[], field:[], score:[], total:0, trait: trait, oneCount: 0 });
    }
    for(let i=0;i<3;i++) players.forEach(p=>p.hand.push(deck.pop()));
    startIndex=0; nextRound();
}

function advanceTurn(){ turnIndex++; if(turnIndex>=playerCount){ turnIndex=0; lap++; } render(); nextTurn(); }
function nextTurn(){ 
    if(lap>3) return startPick(); 
    const p=players[getPlayerIdx(turnIndex)]; 
    updateUIPanels("è´ˆä¸ãƒ‘ãƒ¼ãƒˆ", `ãƒ•ã‚§ã‚¤ã‚º ${lap}`, (p.id === 0) ? "ã‚«ãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚" : `P${p.id}ãŒè€ƒãˆä¸­...`);
    if(p.id!==0 && phase!=="end" && phase!=="title") setTimeout(()=>aiPlay(p),800); 
}
function aiPlay(p){ 
    const d=aiThink(p); 
    if(d.action==="pass") advanceTurn(); 
    else { 
        const c=p.hand.splice(d.index,1)[0]; p.field.push(c); lastPlayOrder.push(p.id); 
        if(deck.length) { p.hand.push(deck.pop()); updateInfo(); }
        playSwooshSound(); advanceTurn(); 
    } 
}
function humanPlay(i){ if(phase!=="play"||getPlayerIdx(turnIndex)!==0)return; const p=players[0]; const c=p.hand.splice(i,1)[0]; p.field.push(c); lastPlayOrder.push(0); if(deck.length){p.hand.push(deck.pop()); updateInfo();} playSwooshSound(); advanceTurn(); }
function pass(){ if(lap===1||phase!=="play"||getPlayerIdx(turnIndex)!==0)return; advanceTurn(); }

function nextRound(){
    if (deck.length === 0 && (players[0].hand.length === 0 || phase === "pick")) return endGame();
    phase="play"; lap=1; turnIndex=0; lastPlayOrder=[]; players.forEach(p=>p.field=[]);
    if(deck.length > 0) { centerCard=deck.pop(); updateInfo(); } else return endGame();
    applyCardDesign(document.getElementById("centerCard"), centerCard.value);
    document.getElementById("centerCard").style.visibility="visible";
    render(); nextTurn();
}

function applyCardDesign(el, val, isBack=false) {
    if(!el) return; el.style.backgroundImage = ""; el.innerText = "";
    if(isBack) { el.className = "card back"; el.style.backgroundImage = `url('card_back.png')`; } 
    else { el.className = "card " + vClass(val); el.style.backgroundImage = `url('card_${val}.png')`; }
}
const vClass=v=>v===-3?"v-3":v===-2?"v-2":v===1?"v1":v===3?"v3":"v4";

function animateCardSlide(fromEl, toSelector, value, hideOnEnd, callback) {
    if (!fromEl) return callback();
    playSwooshSound(); const fromRect = fromEl.getBoundingClientRect();
    const toEl = document.querySelector(toSelector); if (!toEl) return callback();
    const toRect = toEl.getBoundingClientRect();
    const clone = document.createElement('div'); applyCardDesign(clone, value, fromEl.classList.contains('back'));
    clone.classList.add('flying-card'); clone.style.width = fromRect.width + 'px'; clone.style.height = fromRect.height + 'px';
    document.body.appendChild(clone); fromEl.style.visibility = "hidden";
    const anim = clone.animate([{ left: fromRect.left + 'px', top: fromRect.top + 'px' },{ left: toRect.left + 'px', top: toRect.top + 'px' }], { duration: 350, easing: 'ease-out' });
    anim.onfinish = () => { clone.remove(); callback(); };
}

function getPlayerIdx(tIdx) { return (startIndex + tIdx) % playerCount; }

function render(pick=false,allowedIds=[]){
    const t=document.getElementById("table"); t.querySelectorAll(".player").forEach(e=>e.remove());
    const isEnd = (phase === "end");
    const posConfig = { 3:[{x:600,y:450},{x:20,y:450},{x:20,y:20}], 4:[{x:600,y:450},{x:20,y:450},{x:20,y:20},{x:600,y:20}], 5:[{x:600,y:450},{x:20,y:450},{x:20,y:20},{x:400,y:5},{x:750,y:100}] };
    const positions=posConfig[players.length];

    players.forEach((p,i)=>{
        const d=document.createElement("div"); 
        d.className="player player-id-"+p.id+(p.id===0?" human":"") + (isEnd ? " reveal-all" : "");
        d.style.left=positions[i].x+"px"; d.style.top=positions[i].y+"px";
        if(!isEnd && phase==="play" && getPlayerIdx(turnIndex)===p.id) d.style.boxShadow="0 0 20px #f1c40f";
        if(isEnd && p.isAbsoluteWinner) d.style.outline="5px solid #f1c40f";
        let h=`<div style="font-weight:bold;font-size:16px;margin-bottom:8px;text-align:center;color:#f1c40f;">P${p.id}${p.id===0?"(ã‚ãªãŸ)":""} ${p.trait?`[${p.trait.name}]`:""}</div>`;
        d.innerHTML=h;
        const f=document.createElement("div"); f.className="field";
        p.field.forEach((c,ci)=>{ 
            const cd=document.createElement("div"); applyCardDesign(cd,c.value); 
            if(pick&&allowedIds.includes(p.id)){cd.classList.add("selectable");cd.onclick=()=>humanPick(p.id,ci);} f.appendChild(cd); 
        });
        d.appendChild(f);
        const hd=document.createElement("div"); hd.className="hand";
        p.hand.forEach((c,idx)=>{
            const cd=document.createElement("div");
            if(p.id===0 && !isEnd){ applyCardDesign(cd,c.value); cd.onclick=()=>humanPlay(idx); } 
            else if(!isEnd) {
                applyCardDesign(cd,null,true);
                const angle = (idx - (p.hand.length-1)/2) * 15;
                const tx = (idx - (p.hand.length-1)/2) * 20;
                cd.style.transform = `translateX(${tx}px) rotate(${angle}deg)`;
                cd.style.zIndex = idx;
            }
            hd.appendChild(cd);
        });
        d.appendChild(hd);
        const scContainer = document.createElement("div"); scContainer.className="score-container";
        const anchor = document.createElement("div"); anchor.className="score-anchor"; 
        anchor.style.cssText = "width:35px;height:52px;border:1px dashed rgba(255,255,255,0.3);border-radius:4px;z-index:1;";
        if (p.id === 0 || isEnd) {
            const ss = [...p.score]; if(isEnd) ss.sort((a,b)=>a.value-b.value);
            ss.forEach((c) => {
                const scd = document.createElement("div"); applyCardDesign(scd, c.value);
                scd.style.width="35px"; scd.style.height="52px";
                if(isEnd && c.isDead) scd.classList.add("dead");
                scContainer.appendChild(scd);
            });
            if(!isEnd) scContainer.appendChild(anchor);
        } else {
            p.score.forEach((c, sIdx) => {
                const scd = document.createElement("div"); applyCardDesign(scd, null, true);
                scd.style.width="35px"; scd.style.height="52px"; scd.classList.add("score-card-messy");
                const randX = (sIdx % 4) * 2; const randY = (sIdx % 3) * 2; const randRot = (sIdx * 13) % 40 - 20;
                scd.style.left = randX + "px"; scd.style.top = randY + "px"; scd.style.transform = `rotate(${randRot}deg)`;
                scContainer.appendChild(scd);
            });
            scContainer.appendChild(anchor);
        }
        d.appendChild(scContainer);
        if (isEnd) {
            const resDiv = document.createElement("div"); resDiv.style.textAlign="center";
            const lbl=document.createElement("div"); lbl.style.cssText="font-weight:bold;margin-top:10px;font-size:22px;color:#f1c40f;text-shadow:2px 2px 4px black;";
            lbl.innerText=(p.isAbsoluteWinner?"â˜…WINNERâ˜… ":"") + `Score: ${p.total}`; 
            resDiv.appendChild(lbl);
            if(p.id === 0) { 
                const crd = document.createElement("div"); crd.style.fontSize="10px"; crd.style.marginTop="5px"; crd.innerText="Game Design & Illustration: M ";
                const rb = document.createElement("button"); rb.style.marginTop="10px"; rb.innerText="ã‚‚ã†ä¸€åº¦éŠã¶"; rb.onclick=()=>startGame(); 
                resDiv.appendChild(crd); resDiv.appendChild(rb); 
            }
            d.appendChild(resDiv);
        }
        t.appendChild(d);
    });
}
</script>
</body>
</html>